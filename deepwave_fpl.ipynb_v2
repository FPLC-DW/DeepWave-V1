[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/FPLC-DW/DeepWave-V1/blob/main/deepwave_fpl.ipynb_v2)
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# DeepWave FPL Prediction Notebook\n",
    "This notebook fetches live Fantasy Premier League (FPL) data, applies custom scoring rules, and trains a machine learning model to predict future points."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "!pip install requests pandas scikit-learn --quiet"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import requests\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.metrics import mean_absolute_error\n",
    "\n",
    "FPL_API = \"https://fantasy.premierleague.com/api/bootstrap-static/\"\n",
    "\n",
    "# Fetch live data\n",
    "data = requests.get(FPL_API).json()\n",
    "elements = pd.DataFrame(data['elements'])\n",
    "teams = pd.DataFrame(data['teams'])\n",
    "element_types = pd.DataFrame(data['element_types'])\n",
    "\n",
    "print(f\"Fetched {len(elements)} players from FPL API\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Merge position info\n",
    "elements = elements.merge(element_types[['id', 'singular_name']], left_on='element_type', right_on='id', suffixes=('', '_pos'))\n",
    "elements.rename(columns={'singular_name': 'position'}, inplace=True)\n",
    "\n",
    "# Simulate defensive contributions if not available\n",
    "np.random.seed(42)\n",
    "elements['def_contributions'] = np.random.randint(0, 20, size=len(elements))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Apply custom scoring rules\n",
    "def calculate_custom_points(row):\n",
    "    pts = 0\n",
    "    # Minutes\n",
    "    if row['minutes'] >= 60:\n",
    "        pts += 2\n",
    "    elif row['minutes'] > 0:\n",
    "        pts += 1\n",
    "\n",
    "    # Goals\n",
    "    if row['position'] == 'Goalkeeper':\n",
    "        pts += row['goals_scored'] * 10\n",
    "    elif row['position'] == 'Defender':\n",
    "        pts += row['goals_scored'] * 6\n",
    "    elif row['position'] == 'Midfielder':\n",
    "        pts += row['goals_scored'] * 5\n",
    "    elif row['position'] == 'Forward':\n",
    "        pts += row['goals_scored'] * 4\n",
    "\n",
    "    # Assists\n",
    "    pts += row['assists'] * 3\n",
    "\n",
    "    # Clean sheets\n",
    "    if row['position'] in ['Goalkeeper', 'Defender']:\n",
    "        pts += row['clean_sheets'] * 4\n",
    "    elif row['position'] == 'Midfielder':\n",
    "        pts += row['clean_sheets'] * 1\n",
    "\n",
    "    # Saves & Penalties\n",
    "    pts += (row['saves'] // 3) * 1\n",
    "    pts += row['penalties_saved'] * 5\n",
    "\n",
    "    # Defensive contributions\n",
    "    if row['position'] == 'Defender' and row['def_contributions'] >= 10:\n",
    "        pts += 2\n",
    "    elif row['position'] == 'Midfielder' and row['def_contributions'] >= 12:\n",
    "        pts += 2\n",
    "    elif row['position'] == 'Forward' and row['def_contributions'] >= 12:\n",
    "        pts += 2\n",
    "\n",
    "    return pts\n",
    "\n",
    "elements['custom_points'] = elements.apply(calculate_custom_points, axis=1)\n",
    "elements[['web_name', 'position', 'minutes', 'goals_scored', 'assists', 'clean_sheets', 'custom_points']].head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Prepare features for training\n",
    "features = ['minutes', 'goals_scored', 'assists', 'clean_sheets', 'saves', 'penalties_saved', 'def_contributions']\n",
    "X = elements[features]\n",
    "y = elements['custom_points']\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
    "\n",
    "model = RandomForestRegressor(n_estimators=200, random_state=42)\n",
    "model.fit(X_train, y_train)\n",
    "\n",
    "preds = model.predict(X_test)\n",
    "mae = mean_absolute_error(y_test, preds)\n",
    "print(f\"Model MAE: {mae:.2f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Predict points for all players\n",
    "elements['predicted_points'] = model.predict(elements[features])\n",
    "elements[['web_name', 'position', 'predicted_points']].sort_values(by='predicted_points', ascending=False).head(20)"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "name": "deepwave_fpl.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
